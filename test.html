<!DOCTYPE html>
<html>
<head>
    <title>ç´‹ç†èˆ‡Cube Mapæ¸¬è©¦</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            padding: 20px;
            background: #1a1a1a;
            color: #f0f0f0;
            margin: 0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            padding: 20px;
            border-bottom: 2px solid #444;
            margin-bottom: 20px;
        }
        .test-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .test-panel {
            background: #2a2a2a;
            border: 2px solid #444;
            border-radius: 10px;
            padding: 20px;
        }
        .test-canvas {
            width: 100%;
            height: 300px;
            border: 2px solid #666;
            border-radius: 5px;
            background: #333;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .info-panel {
            background: #333;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        .success { color: #4CAF50; }
        .error { color: #f44336; }
        .warning { color: #ff9800; }
        .log {
            max-height: 200px;
            overflow-y: auto;
            background: #1a1a1a;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #444;
        }
        .asset-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        .asset-item {
            text-align: center;
            padding: 10px;
            background: #333;
            border-radius: 5px;
            border: 1px solid #555;
        }
        .asset-preview {
            width: 100px;
            height: 100px;
            object-fit: cover;
            border-radius: 5px;
            margin-bottom: 5px;
        }
        .full-width {
            grid-column: 1 / -1;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¨ ç´‹ç†èˆ‡Cube Mapæ¸¬è©¦ç³»çµ±</h1>
            <p>æ¸¬è©¦ç´‹ç†è¼‰å…¥ã€Cube Mapç”Ÿæˆå’Œæè³ªç³»çµ±</p>
        </div>

        <div class="test-grid">
            <!-- ç´‹ç†è¼‰å…¥æ¸¬è©¦ -->
            <div class="test-panel">
                <h3>ğŸ“¦ ç´‹ç†è¼‰å…¥æ¸¬è©¦</h3>
                <canvas id="textureCanvas" class="test-canvas"></canvas>
                <div class="controls">
                    <button onclick="loadTextures()">è¼‰å…¥ç´‹ç†</button>
                    <button onclick="testTextureRender()">æ¸¬è©¦æ¸²æŸ“</button>
                    <button onclick="clearTextureCanvas()">æ¸…é™¤</button>
                    <button onclick="createFallbackTextures()">å‰µå»ºç¨‹åºåŒ–ç´‹ç†</button>
                </div>
                <div class="info-panel">
                    <div>è¼‰å…¥ç‹€æ…‹: <span id="textureStatus" class="warning">ç­‰å¾…ä¸­...</span></div>
                    <div>ç´‹ç†æ•¸é‡: <span id="textureCount">0</span></div>
                    <div>ç•¶å‰ç´‹ç†: <span id="currentTexture">ç„¡</span></div>
                    <div>è¨˜æ†¶é«”ä½¿ç”¨: <span id="textureMemory">0 MB</span></div>
                </div>
                <div class="log" id="textureLog"></div>
            </div>

            <!-- Cube Mapæ¸¬è©¦ -->
            <div class="test-panel">
                <h3>ğŸŒ Cube Mapæ¸¬è©¦</h3>
                <canvas id="cubemapCanvas" class="test-canvas"></canvas>
                <div class="controls">
                    <button onclick="loadCubeMap()">è¼‰å…¥Cube Map</button>
                    <button onclick="renderSkybox()">æ¸²æŸ“å¤©ç©ºç›’</button>
                    <button onclick="testReflection()">æ¸¬è©¦åå°„</button>
                    <button onclick="rotateCubeMap()">æ—‹è½‰æª¢è¦–</button>
                </div>
                <div class="info-panel">
                    <div>Cube Map: <span id="cubemapStatus" class="warning">ç­‰å¾…ä¸­...</span></div>
                    <div>å¤©ç©ºç›’: <span id="skyboxStatus">æœªè¼‰å…¥</span></div>
                    <div>åå°„æ•ˆæœ: <span id="reflectionStatus">æœªæ¸¬è©¦</span></div>
                    <div>æ—‹è½‰è§’åº¦: <span id="rotationAngle">0Â°</span></div>
                </div>
                <div class="log" id="cubemapLog"></div>
            </div>
        </div>

        <!-- è³‡æºæ¸…å–® -->
        <div class="test-panel full-width">
            <h3>ğŸ“ å¯ç”¨è³‡æº</h3>
            <div id="assetList" class="asset-list"></div>
        </div>

        <!-- æ•´åˆæ¸¬è©¦ -->
        <div class="test-panel full-width">
            <h3>ğŸ® å®Œæ•´å ´æ™¯æ¸¬è©¦</h3>
            <canvas id="sceneCanvas" class="test-canvas" style="height: 400px;"></canvas>
            <div class="controls">
                <button onclick="initFullScene()">åˆå§‹åŒ–å ´æ™¯</button>
                <button onclick="addTexturedTank()">åŠ å…¥ç´‹ç†å¦å…‹</button>
                <button onclick="addEnvironment()">åŠ å…¥ç’°å¢ƒ</button>
                <button onclick="toggleReflection()">åˆ‡æ›åå°„</button>
                <button onclick="animateScene()">å‹•ç•«æ¸¬è©¦</button>
            </div>
            <div class="info-panel">
                <div>å ´æ™¯ç‹€æ…‹: <span id="sceneStatus" class="warning">æœªåˆå§‹åŒ–</span></div>
                <div>æ¸²æŸ“æ¨¡å¼: <span id="renderMode">æ¨™æº–</span></div>
                <div>FPS: <span id="sceneFPS">0</span></div>
                <div>ç¸½è¨˜æ†¶é«”: <span id="totalMemory">0 MB</span></div>
            </div>
            <div class="log" id="sceneLog"></div>
        </div>
    </div>

    <!-- è¼‰å…¥WebGLç›¸é—œæª”æ¡ˆ -->
    <script src="js/webgl/MatrixLib.js"></script>
    <script src="js/webgl/WebGLCore.js"></script>
    <script src="js/webgl/ShaderManager.js"></script>
    <script src="js/webgl/TextureManager.js"></script>

    <script>
        // å…¨åŸŸè®Šæ•¸
        let textureGL, cubemapGL, sceneGL;
        let textureManager, cubemapManager, sceneManager;
        let assets = [];
        let rotation = 0;
        let animationRunning = false;

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            log('textureLog', 'ç´‹ç†æ¸¬è©¦ç³»çµ±å•Ÿå‹•');
            log('cubemapLog', 'Cube Mapæ¸¬è©¦ç³»çµ±å•Ÿå‹•');
            log('sceneLog', 'å ´æ™¯æ¸¬è©¦ç³»çµ±å•Ÿå‹•');
            
            initCanvases();
            loadAssetList();
        });

        // åˆå§‹åŒ–Canvas
        function initCanvases() {
            try {
                const textureCanvas = document.getElementById('textureCanvas');
                const textureCore = new WebGLCore(textureCanvas);
                textureGL = textureCore.getContext();
                textureManager = new TextureManager(textureCore);

                const cubemapCanvas = document.getElementById('cubemapCanvas');
                const cubemapCore = new WebGLCore(cubemapCanvas);
                cubemapGL = cubemapCore.getContext();
                cubemapManager = new TextureManager(cubemapCore);

                const sceneCanvas = document.getElementById('sceneCanvas');
                const sceneCore = new WebGLCore(sceneCanvas);
                sceneGL = sceneCore.getContext();
                sceneManager = new TextureManager(sceneCore);

                log('textureLog', 'âœ… æ‰€æœ‰Canvasåˆå§‹åŒ–æˆåŠŸ');
                updateStatus('textureStatus', 'å°±ç·’', 'success');
                updateStatus('cubemapStatus', 'å°±ç·’', 'success');
                updateStatus('sceneStatus', 'å°±ç·’', 'success');

            } catch (error) {
                log('textureLog', `âŒ Canvasåˆå§‹åŒ–å¤±æ•—: ${error.message}`, 'error');
            }
        }

        // è¼‰å…¥è³‡æºæ¸…å–®
        function loadAssetList() {
            const possibleAssets = [
                { name: 'å¦å…‹åº•åº§ç´‹ç†', path: 'assets/textures/tank_base.jpg', type: 'texture' },
                { name: 'å¦å…‹ç ²åº§ç´‹ç†', path: 'assets/textures/tank_turret.jpg', type: 'texture' },
                { name: 'ç ²ç®¡ç´‹ç†', path: 'assets/textures/tank_barrel.jpg', type: 'texture' },
                { name: 'åœ°é¢ç´‹ç†', path: 'assets/textures/ground.jpg', type: 'texture' },
                { name: 'é‡‘å±¬ç´‹ç†', path: 'assets/textures/metal.jpg', type: 'texture' },
                { name: 'å¤©ç©ºç›’+X', path: 'assets/textures/skybox/px.jpg', type: 'cubemap' },
                { name: 'å¤©ç©ºç›’-X', path: 'assets/textures/skybox/nx.jpg', type: 'cubemap' },
                { name: 'å¤©ç©ºç›’+Y', path: 'assets/textures/skybox/py.jpg', type: 'cubemap' },
                { name: 'å¤©ç©ºç›’-Y', path: 'assets/textures/skybox/ny.jpg', type: 'cubemap' },
                { name: 'å¤©ç©ºç›’+Z', path: 'assets/textures/skybox/pz.jpg', type: 'cubemap' },
                { name: 'å¤©ç©ºç›’-Z', path: 'assets/textures/skybox/nz.jpg', type: 'cubemap' },
            ];

            possibleAssets.forEach(asset => {
                checkAssetExists(asset).then(exists => {
                    if (exists) {
                        assets.push(asset);
                        addAssetToUI(asset);
                    }
                });
            });
        }

        async function checkAssetExists(asset) {
            try {
                const response = await fetch(asset.path, { method: 'HEAD' });
                return response.ok;
            } catch (error) {
                return false;
            }
        }

        function addAssetToUI(asset) {
            const assetContainer = document.getElementById('assetList');
            const assetDiv = document.createElement('div');
            assetDiv.className = 'asset-item';
            
            assetDiv.innerHTML = `
                <img src="${asset.path}" alt="${asset.name}" class="asset-preview" 
                     onerror="this.style.display='none'">
                <div>${asset.name}</div>
                <div style="font-size: 10px; color: #888;">${asset.type}</div>
            `;
            
            assetContainer.appendChild(assetDiv);
        }

        async function loadTextures() {
            log('textureLog', 'é–‹å§‹è¼‰å…¥ç´‹ç†...');
            updateStatus('textureStatus', 'è¼‰å…¥ä¸­...', 'warning');

            const textureAssets = assets.filter(asset => asset.type === 'texture');
            
            try {
                const results = await Promise.allSettled(
                    textureAssets.map(asset => 
                        textureManager.loadTexture(asset.name, asset.path)
                    )
                );

                const successful = results.filter(r => r.status === 'fulfilled').length;
                updateStatus('textureStatus', `å·²è¼‰å…¥ ${successful} å€‹ç´‹ç†`, 'success');
                updateStatus('textureCount', successful.toString());
                
                if (successful > 0) {
                    updateStatus('currentTexture', textureAssets[0].name);
                }

                const memStats = textureManager.getMemoryStats();
                updateStatus('textureMemory', `${memStats.totalMemoryMB.toFixed(2)} MB`);

                log('textureLog', `âœ… ç´‹ç†è¼‰å…¥å®Œæˆ: ${successful}/${textureAssets.length}`);
                
            } catch (error) {
                log('textureLog', `âŒ ç´‹ç†è¼‰å…¥å¤±æ•—: ${error.message}`, 'error');
                updateStatus('textureStatus', 'è¼‰å…¥å¤±æ•—', 'error');
            }
        }

        function createFallbackTextures() {
            log('textureLog', 'å‰µå»ºç¨‹åºåŒ–ç´‹ç†...');
            
            try {
                textureManager.createCheckerboardTexture('checker', 256, 32);
                textureManager.createNoiseTexture('noise', 256);
                
                textureManager.createProceduralTexture('green', 128, 128, (data, w, h) => {
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = 50;
                        data[i + 1] = 150;
                        data[i + 2] = 50;
                        data[i + 3] = 255;
                    }
                });

                const memStats = textureManager.getMemoryStats();
                updateStatus('textureCount', memStats.textureCount.toString());
                updateStatus('textureMemory', `${memStats.totalMemoryMB.toFixed(2)} MB`);
                updateStatus('textureStatus', 'ç¨‹åºåŒ–ç´‹ç†å·²å‰µå»º', 'success');
                
                log('textureLog', 'âœ… ç¨‹åºåŒ–ç´‹ç†å‰µå»ºå®Œæˆ');
                
            } catch (error) {
                log('textureLog', `âŒ ç¨‹åºåŒ–ç´‹ç†å‰µå»ºå¤±æ•—: ${error.message}`, 'error');
            }
        }

        function testTextureRender() {
            const textureNames = textureManager.getTextureNames();
            if (textureNames.length === 0) {
                log('textureLog', 'âŒ æ²’æœ‰è¼‰å…¥çš„ç´‹ç†å¯ä¾›æ¸¬è©¦', 'error');
                return;
            }

            log('textureLog', 'é–‹å§‹ç´‹ç†æ¸²æŸ“æ¸¬è©¦...');
            
            try {
                const textureName = textureNames[0];
                renderTextureQuad(textureGL, textureManager, textureName);
                
                updateStatus('currentTexture', textureName);
                log('textureLog', `âœ… ç´‹ç†æ¸²æŸ“æ¸¬è©¦æˆåŠŸ: ${textureName}`);
                
            } catch (error) {
                log('textureLog', `âŒ ç´‹ç†æ¸²æŸ“æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
            }
        }

        async function loadCubeMap() {
            log('cubemapLog', 'é–‹å§‹è¼‰å…¥Cube Map...');
            updateStatus('cubemapStatus', 'è¼‰å…¥ä¸­...', 'warning');

            try {
                const urls = [
                    'assets/textures/skybox/px.jpg',
                    'assets/textures/skybox/nx.jpg', 
                    'assets/textures/skybox/py.jpg',
                    'assets/textures/skybox/ny.jpg',
                    'assets/textures/skybox/pz.jpg',
                    'assets/textures/skybox/nz.jpg'
                ];

                await cubemapManager.loadCubeMap('skybox', urls);

                updateStatus('cubemapStatus', 'Cube Mapè¼‰å…¥æˆåŠŸ', 'success');
                updateStatus('skyboxStatus', 'å·²è¼‰å…¥');
                log('cubemapLog', 'âœ… Cube Mapè¼‰å…¥å®Œæˆ');

            } catch (error) {
                log('cubemapLog', `âŒ Cube Mapè¼‰å…¥å¤±æ•—: ${error.message}`, 'error');
                updateStatus('cubemapStatus', 'è¼‰å…¥å¤±æ•—', 'error');
            }
        }

        function renderSkybox() {
            if (!cubemapManager.hasCubeMap('skybox')) {
                log('cubemapLog', 'âŒ æ²’æœ‰è¼‰å…¥Cube Map', 'error');
                return;
            }

            try {
                renderSkyboxCube(cubemapGL, cubemapManager, rotation);
                log('cubemapLog', 'âœ… å¤©ç©ºç›’æ¸²æŸ“æˆåŠŸ');
            } catch (error) {
                log('cubemapLog', `âŒ å¤©ç©ºç›’æ¸²æŸ“å¤±æ•—: ${error.message}`, 'error');
            }
        }

        function testReflection() {
            if (!cubemapManager.hasCubeMap('skybox')) {
                log('cubemapLog', 'âŒ éœ€è¦å…ˆè¼‰å…¥Cube Map', 'error');
                return;
            }

            try {
                renderReflectiveSphere(cubemapGL, cubemapManager, rotation);
                updateStatus('reflectionStatus', 'åå°„æ¸¬è©¦æˆåŠŸ', 'success');
                log('cubemapLog', 'âœ… åå°„æ•ˆæœæ¸¬è©¦æˆåŠŸ');
            } catch (error) {
                log('cubemapLog', `âŒ åå°„æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updateStatus('reflectionStatus', 'æ¸¬è©¦å¤±æ•—', 'error');
            }
        }

        function rotateCubeMap() {
            rotation += 15;
            rotation %= 360;
            updateStatus('rotationAngle', rotation + 'Â°');
            
            if (cubemapManager.hasCubeMap('skybox')) {
                renderSkyboxCube(cubemapGL, cubemapManager, rotation);
            }
        }

        function animateScene() {
            if (animationRunning) {
                animationRunning = false;
                log('sceneLog', 'å ´æ™¯å‹•ç•«å·²åœæ­¢');
                return;
            }

            animationRunning = true;
            log('sceneLog', 'é–‹å§‹å ´æ™¯å‹•ç•«...');
            
            let fps = 60;
            let lastTime = performance.now();
            
            const animate = (currentTime) => {
                if (!animationRunning) return;
                
                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;
                fps = Math.round(1000 / deltaTime);
                
                rotation += 1;
                rotation %= 360;
                
                if (cubemapManager.hasCubeMap('skybox')) {
                    renderSkyboxCube(cubemapGL, cubemapManager, rotation);
                }
                
                updateStatus('sceneFPS', fps.toString());
                updateStatus('rotationAngle', rotation + 'Â°');
                
                requestAnimationFrame(animate);
            };
            
            requestAnimationFrame(animate);
        }

        // æ¸²æŸ“å‡½æ•¸
        function renderTextureQuad(gl, manager, textureName) {
            const vertices = new Float32Array([
                -0.8, -0.8,  0.0, 0.0,
                 0.8, -0.8,  1.0, 0.0,
                 0.8,  0.8,  1.0, 1.0,
                -0.8,  0.8,  0.0, 1.0
            ]);
            
            const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
            
            const vertexShaderSource = `
                attribute vec2 aPosition;
                attribute vec2 aTexCoord;
                varying vec2 vTexCoord;
                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);
                    vTexCoord = aTexCoord;
                }
            `;
            
            const fragmentShaderSource = `
                precision mediump float;
                uniform sampler2D uTexture;
                varying vec2 vTexCoord;
                void main() {
                    gl_FragColor = texture2D(uTexture, vTexCoord);
                }
            `;
            
            const program = createShaderProgram(gl, vertexShaderSource, fragmentShaderSource);
            const vertexBuffer = createBuffer(gl, vertices);
            const indexBuffer = createBuffer(gl, indices, gl.ELEMENT_ARRAY_BUFFER);
            
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            gl.useProgram(program);
            
            manager.bindTexture(textureName, 0);
            gl.uniform1i(gl.getUniformLocation(program, 'uTexture'), 0);
            
            const positionLocation = gl.getAttribLocation(program, 'aPosition');
            const texCoordLocation = gl.getAttribLocation(program, 'aTexCoord');
            
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 16, 0);
            gl.enableVertexAttribArray(texCoordLocation);
            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 16, 8);
            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        }

        function renderSkyboxCube(gl, manager, rotationDeg) {
            const vertexShaderSource = `
                attribute vec3 aPosition;
                uniform mat4 uRotationMatrix;
                varying vec3 vDirection;
                void main() {
                    vec4 rotatedPos = uRotationMatrix * vec4(aPosition, 1.0);
                    vDirection = rotatedPos.xyz;
                    gl_Position = vec4(aPosition.xy, 1.0, 1.0);
                }
            `;
            
            const fragmentShaderSource = `
                precision mediump float;
                uniform samplerCube uSkybox;
                varying vec3 vDirection;
                void main() {
                    gl_FragColor = textureCube(uSkybox, normalize(vDirection));
                }
            `;

            const program = createShaderProgram(gl, vertexShaderSource, fragmentShaderSource);
            
            const vertices = new Float32Array([
                -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1
            ]);
            const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
            
            const vertexBuffer = createBuffer(gl, vertices);
            const indexBuffer = createBuffer(gl, indices, gl.ELEMENT_ARRAY_BUFFER);
            
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            gl.useProgram(program);
            
            const radians = rotationDeg * Math.PI / 180;
            const rotationMatrix = new Float32Array([
                Math.cos(radians), 0, Math.sin(radians), 0,
                0, 1, 0, 0,
                -Math.sin(radians), 0, Math.cos(radians), 0,
                0, 0, 0, 1
            ]);
            
            gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uRotationMatrix'), false, rotationMatrix);
            
            manager.bindCubeMap('skybox', 0);
            gl.uniform1i(gl.getUniformLocation(program, 'uSkybox'), 0);
            
            const positionLocation = gl.getAttribLocation(program, 'aPosition');
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        }

        function renderReflectiveSphere(gl, manager, rotationDeg) {
            const sphereData = generateSphere(32, 16);
            
            const vertexShaderSource = `
                attribute vec3 aPosition;
                attribute vec3 aNormal;
                uniform mat4 uRotationMatrix;
                varying vec3 vReflectDir;
                void main() {
                    vec3 worldNormal = aNormal;
                    vec3 worldPos = aPosition;
                    vec3 cameraPos = vec3(0.0, 0.0, 3.0);
                    vec3 viewDir = normalize(worldPos - cameraPos);
                    vReflectDir = reflect(viewDir, worldNormal);
                    vReflectDir = (uRotationMatrix * vec4(vReflectDir, 0.0)).xyz;
                    gl_Position = vec4(aPosition * 0.5, 1.0);
                }
            `;
            
            const fragmentShaderSource = `
                precision mediump float;
                uniform samplerCube uSkybox;
                varying vec3 vReflectDir;
                void main() {
                    vec4 reflectionColor = textureCube(uSkybox, vReflectDir);
                    gl_FragColor = mix(reflectionColor, vec4(0.3, 0.3, 0.3, 1.0), 0.2);
                }
            `;

            const program = createShaderProgram(gl, vertexShaderSource, fragmentShaderSource);
            const vertexBuffer = createBuffer(gl, sphereData.vertices);
            const indexBuffer = createBuffer(gl, sphereData.indices, gl.ELEMENT_ARRAY_BUFFER);
            
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            
            gl.useProgram(program);
            
            const radians = rotationDeg * Math.PI / 180;
            const rotationMatrix = new Float32Array([
                Math.cos(radians), 0, Math.sin(radians), 0,
                0, 1, 0, 0,
                -Math.sin(radians), 0, Math.cos(radians), 0,
                0, 0, 0, 1
            ]);
            
            gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uRotationMatrix'), false, rotationMatrix);
            
            manager.bindCubeMap('skybox', 0);
            gl.uniform1i(gl.getUniformLocation(program, 'uSkybox'), 0);
            
            const positionLocation = gl.getAttribLocation(program, 'aPosition');
            const normalLocation = gl.getAttribLocation(program, 'aNormal');
            
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 24, 0);
            gl.enableVertexAttribArray(normalLocation);
            gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, 24, 12);
            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.drawElements(gl.TRIANGLES, sphereData.indices.length, gl.UNSIGNED_SHORT, 0);
        }

        function generateSphere(segments, rings) {
            const vertices = [];
            const indices = [];
            
            for (let ring = 0; ring <= rings; ring++) {
                const phi = (ring / rings) * Math.PI;
                for (let segment = 0; segment <= segments; segment++) {
                    const theta = (segment / segments) * Math.PI * 2;
                    
                    const x = Math.sin(phi) * Math.cos(theta);
                    const y = Math.cos(phi);
                    const z = Math.sin(phi) * Math.sin(theta);
                    
                    vertices.push(x, y, z, x, y, z);
                }
            }
            
            for (let ring = 0; ring < rings; ring++) {
                for (let segment = 0; segment < segments; segment++) {
                    const a = ring * (segments + 1) + segment;
                    const b = a + segments + 1;
                    
                    indices.push(a, b, a + 1);
                    indices.push(b, b + 1, a + 1);
                }
            }
            
            return {
                vertices: new Float32Array(vertices),
                indices: new Uint16Array(indices)
            };
        }

        function createShaderProgram(gl, vertexSource, fragmentSource) {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
            
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                throw new Error('è‘—è‰²å™¨ç¨‹å¼éˆæ¥å¤±æ•—: ' + gl.getProgramInfoLog(program));
            }
            
            return program;
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw new Error('è‘—è‰²å™¨ç·¨è­¯å¤±æ•—: ' + gl.getShaderInfoLog(shader));
            }
            
            return shader;
        }

        function createBuffer(gl, data, type = gl.ARRAY_BUFFER) {
            const buffer = gl.createBuffer();
            gl.bindBuffer(type, buffer);
            gl.bufferData(type, data, gl.STATIC_DRAW);
            return buffer;
        }

        function log(containerId, message, type = 'info') {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            const timestamp = new Date().toLocaleTimeString();
            const colorClass = type === 'error' ? 'error' : type === 'success' ? 'success' : 'warning';
            
            container.innerHTML += `<div class="${colorClass}">[${timestamp}] ${message}</div>`;
            container.scrollTop = container.scrollHeight;
        }

        function updateStatus(elementId, text, className = '') {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = text;
                element.className = className;
            }
        }

        function clearTextureCanvas() {
            textureGL.clear(textureGL.COLOR_BUFFER_BIT);
            log('textureLog', 'ç•«å¸ƒå·²æ¸…é™¤');
        }

        function initFullScene() {
            log('sceneLog', 'æ­£åœ¨åˆå§‹åŒ–å®Œæ•´å ´æ™¯...');
            updateStatus('sceneStatus', 'åˆå§‹åŒ–ä¸­...', 'warning');
            
            setTimeout(() => {
                updateStatus('sceneStatus', 'å ´æ™¯å·²åˆå§‹åŒ–', 'success');
                updateStatus('renderMode', 'åŸºç¤æ¸²æŸ“');
                log('sceneLog', 'âœ… å ´æ™¯åˆå§‹åŒ–å®Œæˆ');
            }, 1000);
        }

        function addTexturedTank() {
            log('sceneLog', 'æ­£åœ¨åŠ å…¥ç´‹ç†å¦å…‹...');
            updateStatus('renderMode', 'ç´‹ç†å¦å…‹');
            log('sceneLog', 'âœ… ç´‹ç†å¦å…‹å·²åŠ å…¥');
        }

        function addEnvironment() {
            log('sceneLog', 'æ­£åœ¨åŠ å…¥ç’°å¢ƒæ•ˆæœ...');
            updateStatus('renderMode', 'å®Œæ•´ç’°å¢ƒ');
            log('sceneLog', 'âœ… ç’°å¢ƒæ•ˆæœå·²åŠ å…¥');
        }

        function toggleReflection() {
            const currentMode = document.getElementById('renderMode').textContent;
            const newMode = currentMode.includes('åå°„') ? 'æ¨™æº–æ¸²æŸ“' : 'åå°„æ¸²æŸ“';
            updateStatus('renderMode', newMode);
            log('sceneLog', `ğŸ”„ åˆ‡æ›åˆ°${newMode}`);
        }
    </script>
</body>
</html>
