<!DOCTYPE html>
<html>
<head>
    <title>ç´‹ç†èˆ‡Cube Mapæ¸¬è©¦</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            padding: 20px;
            background: #1a1a1a;
            color: #f0f0f0;
            margin: 0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            padding: 20px;
            border-bottom: 2px solid #444;
            margin-bottom: 20px;
        }
        .test-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .test-panel {
            background: #2a2a2a;
            border: 2px solid #444;
            border-radius: 10px;
            padding: 20px;
        }
        .test-canvas {
            width: 100%;
            height: 300px;
            border: 2px solid #666;
            border-radius: 5px;
            background: #333;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .info-panel {
            background: #333;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        .success { color: #4CAF50; }
        .error { color: #f44336; }
        .warning { color: #ff9800; }
        .log {
            max-height: 200px;
            overflow-y: auto;
            background: #1a1a1a;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #444;
        }
        .asset-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        .asset-item {
            text-align: center;
            padding: 10px;
            background: #333;
            border-radius: 5px;
            border: 1px solid #555;
        }
        .asset-preview {
            width: 100px;
            height: 100px;
            object-fit: cover;
            border-radius: 5px;
            margin-bottom: 5px;
        }
        .full-width {
            grid-column: 1 / -1;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¨ ç´‹ç†èˆ‡Cube Mapæ¸¬è©¦ç³»çµ±</h1>
            <p>æ¸¬è©¦ç´‹ç†è¼‰å…¥ã€Cube Mapç”Ÿæˆå’Œæè³ªç³»çµ±</p>
        </div>

        <div class="test-grid">
            <!-- ç´‹ç†è¼‰å…¥æ¸¬è©¦ -->
            <div class="test-panel">
                <h3>ğŸ“¦ ç´‹ç†è¼‰å…¥æ¸¬è©¦</h3>
                <canvas id="textureCanvas" class="test-canvas"></canvas>
                <div class="controls">
                    <button onclick="loadTextures()">è¼‰å…¥ç´‹ç†</button>
                    <button onclick="testTextureRender()">æ¸¬è©¦æ¸²æŸ“</button>
                    <button onclick="clearTextureCanvas()">æ¸…é™¤</button>
                </div>
                <div class="info-panel">
                    <div>è¼‰å…¥ç‹€æ…‹: <span id="textureStatus" class="warning">ç­‰å¾…ä¸­...</span></div>
                    <div>ç´‹ç†æ•¸é‡: <span id="textureCount">0</span></div>
                    <div>ç•¶å‰ç´‹ç†: <span id="currentTexture">ç„¡</span></div>
                </div>
                <div class="log" id="textureLog"></div>
            </div>

            <!-- Cube Mapæ¸¬è©¦ -->
            <div class="test-panel">
                <h3>ğŸŒ Cube Mapæ¸¬è©¦</h3>
                <canvas id="cubemapCanvas" class="test-canvas"></canvas>
                <div class="controls">
                    <button onclick="loadCubeMap()">è¼‰å…¥Cube Map</button>
                    <button onclick="renderSkybox()">æ¸²æŸ“å¤©ç©ºç›’</button>
                    <button onclick="testReflection()">æ¸¬è©¦åå°„</button>
                </div>
                <div class="info-panel">
                    <div>Cube Map: <span id="cubemapStatus" class="warning">ç­‰å¾…ä¸­...</span></div>
                    <div>å¤©ç©ºç›’: <span id="skyboxStatus">æœªè¼‰å…¥</span></div>
                    <div>åå°„æ•ˆæœ: <span id="reflectionStatus">æœªæ¸¬è©¦</span></div>
                </div>
                <div class="log" id="cubemapLog"></div>
            </div>
        </div>

        <!-- è³‡æºæ¸…å–® -->
        <div class="test-panel full-width">
            <h3>ğŸ“ å¯ç”¨è³‡æº</h3>
            <div id="assetList" class="asset-list">
                <!-- å‹•æ…‹è¼‰å…¥ -->
            </div>
        </div>

        <!-- æ•´åˆæ¸¬è©¦ -->
        <div class="test-panel full-width">
            <h3>ğŸ® å®Œæ•´å ´æ™¯æ¸¬è©¦</h3>
            <canvas id="sceneCanvas" class="test-canvas" style="height: 400px;"></canvas>
            <div class="controls">
                <button onclick="initFullScene()">åˆå§‹åŒ–å ´æ™¯</button>
                <button onclick="addTexturedTank()">åŠ å…¥ç´‹ç†å¦å…‹</button>
                <button onclick="addEnvironment()">åŠ å…¥ç’°å¢ƒ</button>
                <button onclick="toggleReflection()">åˆ‡æ›åå°„</button>
                <button onclick="animateScene()">å‹•ç•«æ¸¬è©¦</button>
            </div>
            <div class="info-panel">
                <div>å ´æ™¯ç‹€æ…‹: <span id="sceneStatus" class="warning">æœªåˆå§‹åŒ–</span></div>
                <div>æ¸²æŸ“æ¨¡å¼: <span id="renderMode">æ¨™æº–</span></div>
                <div>FPS: <span id="sceneFPS">0</span></div>
            </div>
            <div class="log" id="sceneLog"></div>
        </div>
    </div>

    <!-- è¼‰å…¥WebGLç›¸é—œæª”æ¡ˆ -->
    <script src="js/webgl/MatrixLib.js"></script>
    <script src="js/webgl/WebGLCore.js"></script>
    <script src="js/webgl/ShaderManager.js"></script>

    <script>
        // å…¨åŸŸè®Šæ•¸
        let textureGL, cubemapGL, sceneGL;
        let textures = new Map();
        let cubeMap = null;
        let assets = [];
        let testRunning = false;

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            log('textureLog', 'ç´‹ç†æ¸¬è©¦ç³»çµ±å•Ÿå‹•');
            log('cubemapLog', 'Cube Mapæ¸¬è©¦ç³»çµ±å•Ÿå‹•');
            log('sceneLog', 'å ´æ™¯æ¸¬è©¦ç³»çµ±å•Ÿå‹•');
            
            initCanvases();
            loadAssetList();
        });

        // åˆå§‹åŒ–Canvas
        function initCanvases() {
            try {
                // ç´‹ç†æ¸¬è©¦Canvas
                const textureCanvas = document.getElementById('textureCanvas');
                textureGL = textureCanvas.getContext('webgl');
                if (!textureGL) throw new Error('ç´‹ç†Canvas WebGLåˆå§‹åŒ–å¤±æ•—');

                // Cube Mapæ¸¬è©¦Canvas
                const cubemapCanvas = document.getElementById('cubemapCanvas');
                cubemapGL = cubemapCanvas.getContext('webgl');
                if (!cubemapGL) throw new Error('Cube Map Canvas WebGLåˆå§‹åŒ–å¤±æ•—');

                // å ´æ™¯æ¸¬è©¦Canvas
                const sceneCanvas = document.getElementById('sceneCanvas');
                sceneGL = sceneCanvas.getContext('webgl');
                if (!sceneGL) throw new Error('å ´æ™¯Canvas WebGLåˆå§‹åŒ–å¤±æ•—');

                log('textureLog', 'âœ… æ‰€æœ‰Canvasåˆå§‹åŒ–æˆåŠŸ');
                updateStatus('textureStatus', 'å°±ç·’', 'success');
                updateStatus('cubemapStatus', 'å°±ç·’', 'success');
                updateStatus('sceneStatus', 'å°±ç·’', 'success');

            } catch (error) {
                log('textureLog', `âŒ Canvasåˆå§‹åŒ–å¤±æ•—: ${error.message}`, 'error');
            }
        }

        // è¼‰å…¥è³‡æºæ¸…å–®
        function loadAssetList() {
            // å®šç¾©å¯èƒ½çš„è³‡æº
            const possibleAssets = [
                // åŸºæœ¬ç´‹ç†
                { name: 'å¦å…‹åº•åº§ç´‹ç†', path: 'assets/textures/tank_base.jpg', type: 'texture' },
                { name: 'å¦å…‹ç ²åº§ç´‹ç†', path: 'assets/textures/tank_turret.jpg', type: 'texture' },
                { name: 'ç ²ç®¡ç´‹ç†', path: 'assets/textures/tank_barrel.jpg', type: 'texture' },
                { name: 'åœ°é¢ç´‹ç†', path: 'assets/textures/ground.jpg', type: 'texture' },
                { name: 'é‡‘å±¬ç´‹ç†', path: 'assets/textures/metal.jpg', type: 'texture' },
                
                // Cube Mapé¢
                { name: 'å¤©ç©ºç›’+X', path: 'assets/textures/skybox/px.jpg', type: 'cubemap' },
                { name: 'å¤©ç©ºç›’-X', path: 'assets/textures/skybox/nx.jpg', type: 'cubemap' },
                { name: 'å¤©ç©ºç›’+Y', path: 'assets/textures/skybox/py.jpg', type: 'cubemap' },
                { name: 'å¤©ç©ºç›’-Y', path: 'assets/textures/skybox/ny.jpg', type: 'cubemap' },
                { name: 'å¤©ç©ºç›’+Z', path: 'assets/textures/skybox/pz.jpg', type: 'cubemap' },
                { name: 'å¤©ç©ºç›’-Z', path: 'assets/textures/skybox/nz.jpg', type: 'cubemap' },
            ];

            const assetContainer = document.getElementById('assetList');
            assetContainer.innerHTML = '';

            possibleAssets.forEach(asset => {
                checkAssetExists(asset).then(exists => {
                    if (exists) {
                        assets.push(asset);
                        addAssetToUI(asset);
                    }
                });
            });
        }

        // æª¢æŸ¥è³‡æºæ˜¯å¦å­˜åœ¨
        async function checkAssetExists(asset) {
            try {
                const response = await fetch(asset.path, { method: 'HEAD' });
                return response.ok;
            } catch (error) {
                return false;
            }
        }

        // æ·»åŠ è³‡æºåˆ°UI
        function addAssetToUI(asset) {
            const assetContainer = document.getElementById('assetList');
            const assetDiv = document.createElement('div');
            assetDiv.className = 'asset-item';
            
            assetDiv.innerHTML = `
                <img src="${asset.path}" alt="${asset.name}" class="asset-preview" 
                     onerror="this.style.display='none'">
                <div>${asset.name}</div>
                <div style="font-size: 10px; color: #888;">${asset.type}</div>
            `;
            
            assetContainer.appendChild(assetDiv);
        }

        // è¼‰å…¥ç´‹ç†
        async function loadTextures() {
            log('textureLog', 'é–‹å§‹è¼‰å…¥ç´‹ç†...');
            updateStatus('textureStatus', 'è¼‰å…¥ä¸­...', 'warning');

            const textureAssets = assets.filter(asset => asset.type === 'texture');
            let loadedCount = 0;

            for (const asset of textureAssets) {
                try {
                    const texture = await loadSingleTexture(textureGL, asset.path);
                    textures.set(asset.name, {
                        texture: texture,
                        path: asset.path,
                        asset: asset
                    });
                    loadedCount++;
                    
                    log('textureLog', `âœ… è¼‰å…¥æˆåŠŸ: ${asset.name}`);
                    updateStatus('currentTexture', asset.name);
                    updateStatus('textureCount', loadedCount.toString());
                    
                } catch (error) {
                    log('textureLog', `âŒ è¼‰å…¥å¤±æ•—: ${asset.name} - ${error.message}`, 'error');
                }
            }

            if (loadedCount > 0) {
                updateStatus('textureStatus', `å·²è¼‰å…¥ ${loadedCount} å€‹ç´‹ç†`, 'success');
                log('textureLog', `âœ… ç´‹ç†è¼‰å…¥å®Œæˆ: ${loadedCount}/${textureAssets.length}`);
            } else {
                updateStatus('textureStatus', 'ç„¡ç´‹ç†è¼‰å…¥', 'error');
                log('textureLog', 'âŒ æ²’æœ‰æˆåŠŸè¼‰å…¥ä»»ä½•ç´‹ç†', 'error');
            }
        }

        // è¼‰å…¥å–®ä¸€ç´‹ç†
        function loadSingleTexture(gl, url) {
            return new Promise((resolve, reject) => {
                const texture = gl.createTexture();
                const image = new Image();
                
                image.crossOrigin = 'anonymous';
                
                image.onload = () => {
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                    
                    // æª¢æŸ¥æ˜¯å¦ç‚º2çš„å†ª
                    if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } else {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    }
                    
                    resolve(texture);
                };
                
                image.onerror = () => {
                    reject(new Error(`ç„¡æ³•è¼‰å…¥åœ–ç‰‡: ${url}`));
                };
                
                image.src = url;
            });
        }

        // æª¢æŸ¥æ•¸å­—æ˜¯å¦ç‚º2çš„å†ª
        function isPowerOf2(value) {
            return (value & (value - 1)) === 0;
        }

        // æ¸¬è©¦ç´‹ç†æ¸²æŸ“
        function testTextureRender() {
            if (textures.size === 0) {
                log('textureLog', 'âŒ æ²’æœ‰è¼‰å…¥çš„ç´‹ç†å¯ä¾›æ¸¬è©¦', 'error');
                return;
            }

            log('textureLog', 'é–‹å§‹ç´‹ç†æ¸²æŸ“æ¸¬è©¦...');
            
            // å‰µå»ºç°¡å–®çš„å››é‚Šå½¢ä¾†é¡¯ç¤ºç´‹ç†
            const vertices = [
                // ä½ç½®      // ç´‹ç†åº§æ¨™
                -0.8, -0.8,  0.0, 0.0,
                 0.8, -0.8,  1.0, 0.0,
                 0.8,  0.8,  1.0, 1.0,
                -0.8,  0.8,  0.0, 1.0
            ];
            
            const indices = [0, 1, 2, 0, 2, 3];
            
            // å‰µå»ºè‘—è‰²å™¨
            const vertexShaderSource = `
                attribute vec2 aPosition;
                attribute vec2 aTexCoord;
                varying vec2 vTexCoord;
                
                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);
                    vTexCoord = aTexCoord;
                }
            `;
            
            const fragmentShaderSource = `
                precision mediump float;
                uniform sampler2D uTexture;
                varying vec2 vTexCoord;
                
                void main() {
                    gl_FragColor = texture2D(uTexture, vTexCoord);
                }
            `;
            
            try {
                const program = createShaderProgram(textureGL, vertexShaderSource, fragmentShaderSource);
                const vertexBuffer = createBuffer(textureGL, vertices);
                const indexBuffer = createBuffer(textureGL, indices, textureGL.ELEMENT_ARRAY_BUFFER);
                
                // è¨­å®šviewport
                textureGL.viewport(0, 0, textureGL.canvas.width, textureGL.canvas.height);
                textureGL.clear(textureGL.COLOR_BUFFER_BIT);
                
                // ä½¿ç”¨ç¬¬ä¸€å€‹ç´‹ç†
                const firstTexture = textures.values().next().value;
                
                textureGL.useProgram(program);
                textureGL.bindTexture(textureGL.TEXTURE_2D, firstTexture.texture);
                textureGL.uniform1i(textureGL.getUniformLocation(program, 'uTexture'), 0);
                
                // è¨­å®šé ‚é»å±¬æ€§
                const positionLocation = textureGL.getAttribLocation(program, 'aPosition');
                const texCoordLocation = textureGL.getAttribLocation(program, 'aTexCoord');
                
                textureGL.bindBuffer(textureGL.ARRAY_BUFFER, vertexBuffer);
                textureGL.enableVertexAttribArray(positionLocation);
                textureGL.vertexAttribPointer(positionLocation, 2, textureGL.FLOAT, false, 16, 0);
                textureGL.enableVertexAttribArray(texCoordLocation);
                textureGL.vertexAttribPointer(texCoordLocation, 2, textureGL.FLOAT, false, 16, 8);
                
                // ç¹ªè£½
                textureGL.bindBuffer(textureGL.ELEMENT_ARRAY_BUFFER, indexBuffer);
                textureGL.drawElements(textureGL.TRIANGLES, 6, textureGL.UNSIGNED_SHORT, 0);
                
                log('textureLog', `âœ… ç´‹ç†æ¸²æŸ“æ¸¬è©¦æˆåŠŸ: ${firstTexture.asset.name}`);
                
            } catch (error) {
                log('textureLog', `âŒ ç´‹ç†æ¸²æŸ“æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
            }
        }

        // è¼‰å…¥Cube Map
        async function loadCubeMap() {
            log('cubemapLog', 'é–‹å§‹è¼‰å…¥Cube Map...');
            updateStatus('cubemapStatus', 'è¼‰å…¥ä¸­...', 'warning');

            const cubemapAssets = assets.filter(asset => asset.type === 'cubemap');
            
            if (cubemapAssets.length < 6) {
                log('cubemapLog', 'âŒ Cube Mapéœ€è¦6å€‹é¢çš„åœ–ç‰‡', 'error');
                updateStatus('cubemapStatus', 'åœ–ç‰‡ä¸è¶³', 'error');
                return;
            }

            try {
                cubeMap = cubemapGL.createTexture();
                cubemapGL.bindTexture(cubemapGL.TEXTURE_CUBE_MAP, cubeMap);

                const faces = [
                    { target: cubemapGL.TEXTURE_CUBE_MAP_POSITIVE_X, name: 'å¤©ç©ºç›’+X' },
                    { target: cubemapGL.TEXTURE_CUBE_MAP_NEGATIVE_X, name: 'å¤©ç©ºç›’-X' },
                    { target: cubemapGL.TEXTURE_CUBE_MAP_POSITIVE_Y, name: 'å¤©ç©ºç›’+Y' },
                    { target: cubemapGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, name: 'å¤©ç©ºç›’-Y' },
                    { target: cubemapGL.TEXTURE_CUBE_MAP_POSITIVE_Z, name: 'å¤©ç©ºç›’+Z' },
                    { target: cubemapGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, name: 'å¤©ç©ºç›’-Z' }
                ];

                let loadedFaces = 0;

                for (const face of faces) {
                    const asset = cubemapAssets.find(a => a.name === face.name);
                    if (asset) {
                        await loadCubeFace(cubemapGL, face.target, asset.path);
                        loadedFaces++;
                        log('cubemapLog', `âœ… è¼‰å…¥é¢: ${face.name}`);
                    }
                }

                if (loadedFaces === 6) {
                    cubemapGL.texParameteri(cubemapGL.TEXTURE_CUBE_MAP, cubemapGL.TEXTURE_MIN_FILTER, cubemapGL.LINEAR);
                    cubemapGL.texParameteri(cubemapGL.TEXTURE_CUBE_MAP, cubemapGL.TEXTURE_MAG_FILTER, cubemapGL.LINEAR);
                    cubemapGL.texParameteri(cubemapGL.TEXTURE_CUBE_MAP, cubemapGL.TEXTURE_WRAP_S, cubemapGL.CLAMP_TO_EDGE);
                    cubemapGL.texParameteri(cubemapGL.TEXTURE_CUBE_MAP, cubemapGL.TEXTURE_WRAP_T, cubemapGL.CLAMP_TO_EDGE);

                    updateStatus('cubemapStatus', 'Cube Mapè¼‰å…¥æˆåŠŸ', 'success');
                    updateStatus('skyboxStatus', 'å·²è¼‰å…¥');
                    log('cubemapLog', 'âœ… Cube Mapè¼‰å…¥å®Œæˆ');
                } else {
                    throw new Error(`åªè¼‰å…¥äº† ${loadedFaces}/6 å€‹é¢`);
                }

            } catch (error) {
                log('cubemapLog', `âŒ Cube Mapè¼‰å…¥å¤±æ•—: ${error.message}`, 'error');
                updateStatus('cubemapStatus', 'è¼‰å…¥å¤±æ•—', 'error');
            }
        }

        // è¼‰å…¥Cube Mapå–®ä¸€é¢
        function loadCubeFace(gl, target, url) {
            return new Promise((resolve, reject) => {
                const image = new Image();
                image.crossOrigin = 'anonymous';
                
                image.onload = () => {
                    gl.texImage2D(target, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                    resolve();
                };
                
                image.onerror = () => {
                    reject(new Error(`ç„¡æ³•è¼‰å…¥Cube Mapé¢: ${url}`));
                };
                
                image.src = url;
            });
        }

        // æ¸²æŸ“å¤©ç©ºç›’
        function renderSkybox() {
            if (!cubeMap) {
                log('cubemapLog', 'âŒ æ²’æœ‰è¼‰å…¥Cube Map', 'error');
                return;
            }

            log('cubemapLog', 'æ¸²æŸ“å¤©ç©ºç›’æ¸¬è©¦...');
            
            // å¤©ç©ºç›’è‘—è‰²å™¨
            const vertexShaderSource = `
                attribute vec3 aPosition;
                varying vec3 vDirection;
                
                void main() {
                    vDirection = aPosition;
                    gl_Position = vec4(aPosition.xy, 1.0, 1.0);
                }
            `;
            
            const fragmentShaderSource = `
                precision mediump float;
                uniform samplerCube uSkybox;
                varying vec3 vDirection;
                
                void main() {
                    gl_FragColor = textureCube(uSkybox, normalize(vDirection));
                }
            `;

            try {
                const program = createShaderProgram(cubemapGL, vertexShaderSource, fragmentShaderSource);
                
                // å…¨è¢å¹•å››é‚Šå½¢
                const vertices = [
                    -1, -1, 0,
                     1, -1, 0,
                     1,  1, 0,
                    -1,  1, 0
                ];
                const indices = [0, 1, 2, 0, 2, 3];
                
                const vertexBuffer = createBuffer(cubemapGL, vertices);
                const indexBuffer = createBuffer(cubemapGL, indices, cubemapGL.ELEMENT_ARRAY_BUFFER);
                
                cubemapGL.viewport(0, 0, cubemapGL.canvas.width, cubemapGL.canvas.height);
                cubemapGL.clear(cubemapGL.COLOR_BUFFER_BIT);
                
                cubemapGL.useProgram(program);
                cubemapGL.bindTexture(cubemapGL.TEXTURE_CUBE_MAP, cubeMap);
                cubemapGL.uniform1i(cubemapGL.getUniformLocation(program, 'uSkybox'), 0);
                
                const positionLocation = cubemapGL.getAttribLocation(program, 'aPosition');
                cubemapGL.bindBuffer(cubemapGL.ARRAY_BUFFER, vertexBuffer);
                cubemapGL.enableVertexAttribArray(positionLocation);
                cubemapGL.vertexAttribPointer(positionLocation, 3, cubemapGL.FLOAT, false, 0, 0);
                
                cubemapGL.bindBuffer(cubemapGL.ELEMENT_ARRAY_BUFFER, indexBuffer);
                cubemapGL.drawElements(cubemapGL.TRIANGLES, 6, cubemapGL.UNSIGNED_SHORT, 0);
                
                log('cubemapLog', 'âœ… å¤©ç©ºç›’æ¸²æŸ“æˆåŠŸ');
                
            } catch (error) {
                log('cubemapLog', `âŒ å¤©ç©ºç›’æ¸²æŸ“å¤±æ•—: ${error.message}`, 'error');
            }
        }

        // æ¸¬è©¦åå°„
        function testReflection() {
            if (!cubeMap) {
                log('cubemapLog', 'âŒ éœ€è¦å…ˆè¼‰å…¥Cube Map', 'error');
                return;
            }

            log('cubemapLog', 'æ¸¬è©¦åå°„æ•ˆæœ...');
            updateStatus('reflectionStatus', 'æ¸¬è©¦ä¸­...');

            // å‰µå»ºåå°„çƒé«”
            const sphereVertices = generateSphere(32, 16);
            
            const vertexShaderSource = `
                attribute vec3 aPosition;
                attribute vec3 aNormal;
                uniform mat4 uViewMatrix;
                varying vec3 vReflectDir;
                
                void main() {
                    vec3 worldNormal = aNormal;
                    vec3 worldPos = aPosition;
                    vec3 cameraPos = vec3(0.0, 0.0, 3.0);
                    
                    vec3 viewDir = normalize(worldPos - cameraPos);
                    vReflectDir = reflect(viewDir, worldNormal);
                    
                    gl_Position = vec4(aPosition * 0.5, 1.0);
                }
            `;
            
            const fragmentShaderSource = `
                precision mediump float;
                uniform samplerCube uSkybox;
                varying vec3 vReflectDir;
                
                void main() {
                    vec4 reflectionColor = textureCube(uSkybox, vReflectDir);
                    gl_FragColor = mix(reflectionColor, vec4(0.3, 0.3, 0.3, 1.0), 0.3);
                }
            `;

            try {
                const program = createShaderProgram(cubemapGL, vertexShaderSource, fragmentShaderSource);
                const vertexBuffer = createBuffer(cubemapGL, sphereVertices.vertices);
                const indexBuffer = createBuffer(cubemapGL, sphereVertices.indices, cubemapGL.ELEMENT_ARRAY_BUFFER);
                
                cubemapGL.clear(cubemapGL.COLOR_BUFFER_BIT | cubemapGL.DEPTH_BUFFER_BIT);
                cubemapGL.enable(cubemapGL.DEPTH_TEST);
                
                cubemapGL.useProgram(program);
                cubemapGL.bindTexture(cubemapGL.TEXTURE_CUBE_MAP, cubeMap);
                cubemapGL.uniform1i(cubemapGL.getUniformLocation(program, 'uSkybox'), 0);
                
                const positionLocation = cubemapGL.getAttribLocation(program, 'aPosition');
                const normalLocation = cubemapGL.getAttribLocation(program, 'aNormal');
                
                cubemapGL.bindBuffer(cubemapGL.ARRAY_BUFFER, vertexBuffer);
                cubemapGL.enableVertexAttribArray(positionLocation);
                cubemapGL.vertexAttribPointer(positionLocation, 3, cubemapGL.FLOAT, false, 24, 0);
                cubemapGL.enableVertexAttribArray(normalLocation);
                cubemapGL.vertexAttribPointer(normalLocation, 3, cubemapGL.FLOAT, false, 24, 12);
                
                cubemapGL.bindBuffer(cubemapGL.ELEMENT_ARRAY_BUFFER, indexBuffer);
                cubemapGL.drawElements(cubemapGL.TRIANGLES, sphereVertices.indices.length, cubemapGL.UNSIGNED_SHORT, 0);
                
                updateStatus('reflectionStatus', 'åå°„æ¸¬è©¦æˆåŠŸ', 'success');
                log('cubemapLog', 'âœ… åå°„æ•ˆæœæ¸¬è©¦æˆåŠŸ');
                
            } catch (error) {
                log('cubemapLog', `âŒ åå°„æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updateStatus('reflectionStatus', 'æ¸¬è©¦å¤±æ•—', 'error');
            }
        }

        // ç”Ÿæˆçƒé«”å¹¾ä½•
        function generateSphere(segments, rings) {
            const vertices = [];
            const indices = [];
            
            for (let ring = 0; ring <= rings; ring++) {
                const phi = (ring / rings) * Math.PI;
                for (let segment = 0; segment <= segments; segment++) {
                    const theta = (segment / segments) * Math.PI * 2;
                    
                    const x = Math.sin(phi) * Math.cos(theta);
                    const y = Math.cos(phi);
                    const z = Math.sin(phi) * Math.sin(theta);
                    
                    vertices.push(x, y, z, x, y, z); // ä½ç½® + æ³•å‘é‡
                }
            }
            
            for (let ring = 0; ring < rings; ring++) {
                for (let segment = 0; segment < segments; segment++) {
                    const a = ring * (segments + 1) + segment;
                    const b = a + segments + 1;
                    
                    indices.push(a, b, a + 1);
                    indices.push(b, b + 1, a + 1);
                }
            }
            
            return {
                vertices: new Float32Array(vertices),
                indices: new Uint16Array(indices)
            };
        }

        // å·¥å…·å‡½æ•¸
        function createShaderProgram(gl, vertexSource, fragmentSource) {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
            
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                throw new Error('è‘—è‰²å™¨ç¨‹å¼éˆæ¥å¤±æ•—: ' + gl.getProgramInfoLog(program));
            }
            
            return program;
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw new Error('è‘—è‰²å™¨ç·¨è­¯å¤±æ•—: ' + gl.getShaderInfoLog(shader));
            }
            
            return shader;
        }

        function createBuffer(gl, data, type = gl.ARRAY_BUFFER) {
            const buffer = gl.createBuffer();
            gl.bindBuffer(type, buffer);
            gl.bufferData(type, data, gl.STATIC_DRAW);
            return buffer;
        }

        // UIå·¥å…·å‡½æ•¸
        function log(containerId, message, type = 'info') {
            const container = document.getElementById(containerId);
            const timestamp = new Date().toLocaleTimeString();
            const colorClass = type === 'error' ? 'error' : type === 'success' ? 'success' : 'warning';
            
            container.innerHTML += `<div class="${colorClass}">[${timestamp}] ${message}</div>`;
            container.scrollTop = container.scrollHeight;
        }

        function updateStatus(elementId, text, className = '') {
            const element = document.getElementById(elementId);
            element.textContent = text;
            element.className = className;
        }

        function clearTextureCanvas() {
            textureGL.clear(textureGL.COLOR_BUFFER_BIT);
            log('textureLog', 'ç•«å¸ƒå·²æ¸…é™¤');
        }

        // å ´æ™¯æ¸¬è©¦åŠŸèƒ½ï¼ˆå¾…å¯¦ç¾ï¼‰
        function initFullScene() {
            log('sceneLog', 'å®Œæ•´å ´æ™¯æ¸¬è©¦åŠŸèƒ½é–‹ç™¼ä¸­...');
        }

        function addTexturedTank() {
            log('sceneLog', 'ç´‹ç†å¦å…‹åŠŸèƒ½é–‹ç™¼ä¸­...');
        }

        function addEnvironment() {
            log('sceneLog', 'ç’°å¢ƒåŠŸèƒ½é–‹ç™¼ä¸­...');
        }

        function toggleReflection() {
            log('sceneLog', 'åå°„åˆ‡æ›åŠŸèƒ½é–‹ç™¼ä¸­...');
        }

        function animateScene() {
            log('sceneLog', 'å ´æ™¯å‹•ç•«åŠŸèƒ½é–‹ç™¼ä¸­...');
        }
    </script>
</body>
</html>
